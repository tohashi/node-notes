// Generated by CoffeeScript 1.7.1
(function() {
  var Notes, async, colors, fs, _;

  fs = require('fs');

  colors = require('colors');

  async = require('async');

  _ = require('underscore');

  Notes = (function() {
    var eachLineIn, filesUnderDirectory, setDefaultRegExp;

    setDefaultRegExp = function(name) {
      return new RegExp("^.*(#|\\/\\/|\\/\\*)\\s*" + name + ":?\\s*");
    };

    Notes.patterns = {
      todo: {
        name: "TODO",
        label: "✓ TODO",
        color: "magenta"
      },
      note: {
        name: "NOTE",
        label: "✐ NOTE",
        color: "blue"
      },
      optimize: {
        name: "OPTIMIZE",
        label: "↘ OPTIMIZE",
        color: "yellow"
      },
      fixme: {
        name: "FIXME",
        label: "☂ FIXME",
        color: "red"
      }
    };

    Notes.filterExtensions = ["\\.jpg", "\\.jpeg", "\\.mov", "\\.mp3", "\\.gif", "\\.png", "\\.log", "\\.bin", "\\.psd", "\\.swf", "\\.fla", "\\.ico"];

    Notes.filterDirectories = ["node_modules"];

    Notes.skipHidden = true;

    function Notes(rootDir, options) {
      this.rootDir = rootDir;
      if (!this.rootDir) {
        throw "Root directory is required.";
      }
      this.patterns = _.map(_.extend((options != null ? options.annotations : void 0) || {}, Notes.patterns), function(pattern) {
        pattern.regexp = setDefaultRegExp(pattern.name);
        pattern.label = pattern.label.underline[pattern.color || "white"];
        return pattern;
      });
    }

    Notes.prototype.annotate = function(done) {
      var files, output, run;
      files = [];
      filesUnderDirectory(this.rootDir, function(file) {
        return files.push(file);
      });
      output = {};
      run = (function(_this) {
        return function(file, _done) {
          var onCompletion, onLine;
          onLine = function(line, lineNum, filePath) {
            var key, lineNumStr, n, pattern, spaces, _i, _len, _ref, _ref1, _results;
            _ref = _this.patterns;
            _results = [];
            for (key in _ref) {
              pattern = _ref[key];
              if (line.match(pattern.regexp) != null) {
                if (output[filePath] == null) {
                  output[filePath] = ("* " + (filePath.replace('//', '/')) + "\n").green;
                }
                line = line.replace(pattern.regexp, '');
                spaces = '     ';
                _ref1 = (lineNum + 1).toString();
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                  n = _ref1[_i];
                  spaces = spaces.substring(0, spaces.length - 1);
                }
                lineNumStr = ("Line " + lineNum + ":").grey;
                _results.push(output[filePath] += "  " + lineNumStr + spaces + pattern.label + " " + line + "\n");
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          };
          onCompletion = function(filePath) {
            if (output[filePath] != null) {
              console.log(output[filePath]);
            }
            return _done();
          };
          return eachLineIn(file, onLine, onCompletion);
        };
      })(this);
      return async.waterfall(_.map(files, function(file) {
        return function(_done) {
          return run(file, _done);
        };
      }), function(err, results) {
        return typeof done === "function" ? done(results) : void 0;
      });
    };

    filesUnderDirectory = function(dir, fileCallback) {
      var error, f, files, filter, _i, _len, _results;
      try {
        files = fs.readdirSync(dir);
        if (files != null) {
          if (Notes.skipHidden) {
            files = (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = files.length; _i < _len; _i++) {
                f = files[_i];
                if (!f.match(/^\./)) {
                  _results.push(f);
                }
              }
              return _results;
            })();
          }
          files = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = files.length; _i < _len; _i++) {
              f = files[_i];
              if (Notes.filterDirectories.indexOf(f) < 0) {
                _results.push(f);
              }
            }
            return _results;
          })();
          _results = [];
          for (_i = 0, _len = files.length; _i < _len; _i++) {
            f = files[_i];
            _results.push(filesUnderDirectory("" + dir + "/" + f, fileCallback));
          }
          return _results;
        }
      } catch (_error) {
        error = _error;
        if (error.code === "ENOTDIR") {
          filter = RegExp("(" + (Notes.filterExtensions.join('|')) + ")$");
          if (!dir.match(filter)) {
            return fileCallback(dir);
          }
        } else if (error.code === "ELOOP") {
          return console.log("" + error + "... continuing.");
        } else {
          throw error;
        }
      }
    };

    eachLineIn = function(filePath, onLine, onCompletion) {
      return fs.readFile(filePath, function(err, data) {
        var i, line, lines, _i, _len;
        if (err != null) {
          throw err;
        }
        lines = data.toString('utf-8').split("\n");
        for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
          line = lines[i];
          onLine(line, i + 1, filePath);
        }
        return onCompletion(filePath);
      });
    };

    return Notes;

  })();

  module.exports = Notes;

}).call(this);
